/* FIRST Team 1073's RobotBuilder (0.0.2) for WPILibExtensions ---
Do not mix this code with any other version of RobotBuilder! */
#include "DriveTrain.h"
#include "../Robotmap.h"
#include "../Commands/drive.h"
const float TWIST_CONSTANT = 0.7f;
const float TWIST_DEADZONE = 0.25f;
const float X_DEADZONE = 0.25f;
const float Y_DEADZONE = 0.25f;
DriveTrain::DriveTrain() : Subsystem("DriveTrain") {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	gyro = RobotMap::driveTrainGyro;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	rightBack = RobotMap::driveTrainRightBack;
	leftBack = RobotMap::driveTrainLeftBack;
	leftFront = RobotMap::driveTrainLeftFront;
	rightFront = RobotMap::driveTrainRightFront;
	isDriveTrainReady=false;
	leftBackOK=false;
	leftFrontOK=false;
	rightBackOK=false;
	rightFrontOK=false;
}
void DriveTrain::InitDefaultCommand() {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new drive());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}
void DriveTrain::MecanumDrive(float joystickX, float joystickY, float joystickTwist) {
	//add some deadzones
	if(joystickTwist < TWIST_DEADZONE && joystickTwist > -TWIST_DEADZONE){
					joystickTwist = 0.001;
				}
	if(joystickX < X_DEADZONE && joystickX > -X_DEADZONE){
						joystickX = 0.001;
					}
	if(joystickY < Y_DEADZONE && joystickY > -Y_DEADZONE){
						joystickY = 0.001;
					}
	double angle = atan2(joystickX, joystickY);
	float joystickMagnitude = sqrt((joystickX * joystickX) + (joystickY * joystickY));
	float ccTwist = joystickTwist * TWIST_CONSTANT;
	float twist = -joystickTwist * TWIST_CONSTANT;
		
	float leftFrontVal = -1 * (ccTwist + joystickMagnitude*(cos(angle)+sin(angle)));
	float rightFrontVal = (twist + joystickMagnitude*(cos(angle)-sin(angle)));
	float leftBackVal= -1 * (ccTwist + joystickMagnitude*(cos(angle)-sin(angle)));
	float rightBackVal = (twist + joystickMagnitude*(cos(angle)+sin(angle)));
		
	leftFront->Set(leftFrontVal);
	rightFront->Set(rightFrontVal);
	leftBack->Set(leftBackVal);
	rightBack->Set(rightBackVal);
}
void DriveTrain::AutoFoward(){
	leftFront->Set(-0.5f);
	rightFront->Set(0.5f);
	leftBack->Set(-0.5f);
	rightBack->Set(0.5f);
}
void DriveTrain::AutoReverse(){
	leftFront->Set(0.5f);
	rightFront->Set(-0.5f);
	leftBack->Set(0.5f);
	rightBack->Set(-0.5f);
}
void DriveTrain::Stop(){
	leftFront->Set(0);
	rightFront->Set(0);
	leftBack->Set(0);
	rightBack->Set(0);
}
bool DriveTrain::isGyroReady(){
	//float theAngle = gyro->GetAngle();
	//we know the gyro is broken
	float theAngle = 250.0f;
	return ((0<theAngle)&&(theAngle<360));
}
void DriveTrain::AreWheelsOK(){
	leftBackOK=false;
	leftFrontOK=false;
	rightBackOK=false;
	rightFrontOK=false;
	
	float leftFrontSpeed = leftFront->Get();
	float rightFrontSpeed = rightFront->Get();
	float leftBackSpeed = leftBack->Get();
	float rightBackSpeed = rightBack->Get();

	if((-.4f>leftFrontSpeed)&&(leftFrontSpeed>-.6f))
		leftFrontOK=true;
	if((.4f<rightFrontSpeed)&&(rightFrontSpeed<.6f))
		rightFrontOK=true;
	if((-.4f>leftBackSpeed)&&(leftBackSpeed>-.6f))
		leftBackOK=true;
	if((.4f<rightBackSpeed)&&(rightBackSpeed<.6f))
		rightBackOK=true;
	if(leftFrontOK&&leftBackOK&&rightFrontOK&&rightBackOK)
		isDriveTrainReady=true;
}
